local triggers  = require "in.triggers"
local light     = require 'light_and_shadows.light'
local common    = require 'helper.common'
local broadcast = require 'helper.broadcast'
local constants = require "light_and_shadows.constants"
local fow       = require 'examples.tinyworld.fow'
local map       = require 'examples.tinyworld.map'
local astar     = require 'examples.tinyworld.astar'

go.property("camera_go_id", msg.url("camera"))
go.property("camera_id", msg.url("camera#camera"))
go.property("cam_look_at", msg.url("cam_target"))
go.property("acquire_delay", 0)
go.property("zoom_speed", 1)

-- Texture for fog-of-war (used as a resource)
go.property("fow", resource.texture(""))
local root     = vmath.vector3(0, 0, 0)
local up       = vmath.vector3(0, 1, 0)


local perlin = require 'examples.tinyworld.perlin'
perlin:load()

local TILE_SIZE = 16
local SCALE = vmath.vector3(16)
local objects = {}
local t = {
    move = 0,
    tree = 1,
    house = 2,
    tower = 3,
}
local props = {
    tree =  {"#tree_bill", "#tree_bill1", "#tree_bill2", "#tree_bill3", "#tree_bill4", "#tree_bill5", "#tree_bill6", "#tree_bill5"},
    house = {"#b3", "#b4", "#b5", "#b6", "#b7"},
    bighouse = {"#b2"},
    tower = {"tower_wall"},
    tree2 = {"#treeb_1", "#treeb_2", "#treeb_3", "#treeb_4", "#billboard", "#billboard2", "#billboard3", "#billboard4", "#billboard5", "#billboard6" }
}
local total = 0
local MAP_WIDTH = 64
local MAP_HEIGHT = 64
local world = {}

local function pos_xy(x, y, h)
    return vmath.vector3((x -.5 - MAP_WIDTH/2)* TILE_SIZE,  h or 0, (y - MAP_HEIGHT/2 - .5)* TILE_SIZE)
end

local function pos_xy_rnd(x, y, h, rnd)
    return vmath.vector3((x -.5 - MAP_WIDTH/2)* TILE_SIZE + math.random()*rnd - rnd/2,  h or 0, (y - MAP_HEIGHT/2 - .5)* TILE_SIZE + math.random()*rnd - rnd/2)
end

local function generate(self)

    local turl = msg.url("/tilemap#tw")

    map.init(MAP_WIDTH, MAP_HEIGHT, TILE_SIZE)
    -- for y = 1, MAP_HEIGHT do
    --     for x = 1, MAP_WIDTH do
    --         local t = tilemap.get_tile(turl, "map", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1))
    --         if t > 0 then
    --             map.set(x, y, map.solid)
    --         end
    --     end
    -- end


    local temp = {}
    local scale = 1 / 8


    for y = 1, MAP_HEIGHT do
        temp[y] = {}
        objects[y] = {}
        world[y] = {} 
        for x = 1, MAP_WIDTH do
            temp[y][x] = 0
            world[y][x] = 1
            tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), common.get_one_from({108, 111, 105, 102, 118}))
            local v = 0.5 + (perlin:noise(x * scale, y * scale, 0) + 0.5 * perlin:noise(2 * x * scale, 2 * y * scale, 0.1) + 0.25 * perlin:noise(4 * x * scale, 4 * y * scale, 0.2)) / 2
            -- local v = (0.5 + perlin:noise(x * scale, y * scale, 0) / 2)
            if v > 0.5 and v <= 0.6 then
                temp[y][x] = 1
                tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), common.get_one_from({5, 6}))
            elseif v > 0.6 and v <= 0.7 then
                local position = pos_xy_rnd(x, y, 0, 8)
                -- local id = factory.create(common.get_one_from{"#billboard"}, position, nil, nil, vmath.vector3(1))
                local name = common.get_one_from(props.tree2)
                local id = factory.create(name, position, nil, nil)

                if math.random() < .4 then
                    factory.create(common.get_one_from(props.tree2), pos_xy_rnd(x, y, 0, 12), nil, nil)
                end
                if math.random() < .4 then
                    factory.create(common.get_one_from(props.tree2), pos_xy_rnd(x, y, 0, 24), nil, nil)
                end

                objects[y][x] = {id = id, t = t.tree }
                total = total + 1
                temp[y][x] = 1
                tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), common.get_one_from({8, 5, 6}))
                map.set(x, y, map.solid)
                world[y][x] = 0
            -- elseif v > 0.1 and v <= 0.14 then
            --     local position = vmath.vector3((x -.5 - MAP_WIDTH/2)* TILE_SIZE, 0, (y - MAP_HEIGHT/2 - .5)* TILE_SIZE)
            --     local name = common.get_one_from(props.house)
            --     local id = factory.create(name, position, nil, nil, SCALE)
            --     objects[y][x] = {id = id, t = t.house}
            --     total = total + 1
            --     map.set(x, y, map.solid)
            end

            -- Setup map pass posibility from tilemap
            local t = tilemap.get_tile(turl, "map", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1))
            if t > 0 then
                map.set(x, y, map.solid)
            end
        end
    end

    for y = 2, MAP_HEIGHT do
        for x = 2, MAP_WIDTH do
            if temp[y][x] == 1 then
                temp[y][x -1] = 1
                tilemap.set_tile(turl, "ground", (x - 1 - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), common.get_one_from({5, 6}))
                -- map[y-1][x] = 1
                -- tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 2), common.get_one_from({5, 6}))
            end

        end
        for x = MAP_WIDTH-1, 1, -1 do
            if temp[y][x] == 1 then
                temp[y][x +1] = 1
                tilemap.set_tile(turl, "ground", (x + 1 - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), common.get_one_from({5, 6}))
            end
        end
    end
    for y = 2, MAP_HEIGHT-1 do
        for x = 2, MAP_WIDTH-1 do
            if temp[y][x] == 0 then
                if temp[y][x-1] == 1     then tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), 99) end
                if temp[y][x+1] == 1     then tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), 97) end
            end
        end
    end
    for y = 2, MAP_HEIGHT-1 do
        for x = 2, MAP_WIDTH-1 do
            if temp[y][x] == 0 then
                if temp[y-1][x] == 1     then tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), 114) end
                if temp[y+1][x] == 1     then tilemap.set_tile(turl, "ground", (x - MAP_WIDTH/2), (MAP_HEIGHT/2 - y + 1), 82) end
            end
        end
    end

end
local selected = t.move
local function neighbours(y, x, typ)
    local x = common.clamp(x, 2, MAP_WIDTH - 1)
    local y = common.clamp(y, 2, MAP_HEIGHT -1)
    if objects[y][x - 1] and objects[y][x -1].t == typ then
        if objects[y][x + 1] and objects[y][x + 1].t == typ then
            return true
        end
    end
    return false
end

local function erase(x, y)
    local obj = objects[y][x]
    if obj then
        go.delete(obj.id)
        objects[y][x] = nil
        total = total - 1
        map.set(x, y, map.empty)
    end
end

local heroes = {
    {
        name = "ABC",
        x = MAP_WIDTH / 2,
        y = MAP_HEIGHT / 2,
        id = "boy",
        sprite = "boy#sprite",
        visible_radius = 12,
    }
}
local function follow_path(obj, path, marks, step_cb)
    if path and #path == 0 then return end
    obj.path_index = 1
    obj.path = path

    local function step()

        if obj.path and obj.path_index < #obj.path then
            local tx, ty = obj.x, obj.y

            obj.path_index = obj.path_index + 1
            local p = obj.path[obj.path_index]

            if p then
                local temp = pos_xy(p.x, p.y)

                local time = .2
                if tx ~= p.x and ty ~= p.y then
                    time = time * 1.41
                end


                if tx == p.x then
                elseif tx < p.x then
                    if obj.sprite then
                        sprite.set_hflip(obj.sprite, false)
                    else
                        go.set(obj.id, "scale.x", 1)
                    end
                else
                    if obj.sprite then
                        sprite.set_hflip(obj.sprite, true)
                    else
                        go.set(obj.id, "scale.x", -1)
                    end
                end

                local easing = go.EASING_LINEAR
                go.animate(obj.id, "position.x", go.PLAYBACK_ONCE_FORWARD, temp.x, easing, time, 0, step)
                go.animate(obj.id, "position.z", go.PLAYBACK_ONCE_FORWARD, temp.z, easing, time)
                go.set(obj.id, "position.y", 0)
                go.animate(obj.id, "position.y", go.PLAYBACK_ONCE_PINGPONG, 2, easing, time)
                go.animate(obj.id, "euler.z", go.PLAYBACK_ONCE_PINGPONG, (obj.path_index %2 == 0 and 5 or -5) , easing, time)

                obj.x = p.x
                obj.y = p.y
                obj.prev_x = tx
                obj.prev_y = ty

                if step_cb then
                    step_cb(obj)
                end
            end
        elseif obj.path then
            -- done job
            if step_cb then
                step_cb(obj, true)
            end
            print("done")
        end

    end

    step()
end

local function noway(x,y)
    local id = factory.create("#point", pos_xy(x, y, 1))
    sprite.play_flipbook(msg.url(nil, id, "sprite"), "noway")
    timer.delay(.4, false, function (self, handle, time_elapsed)
        go.delete(id)
    end)
end

local DEBUG = false
local function point(v)
    local id
    if DEBUG then
        id = factory.create("#debug", pos_xy(v.x, v.y, 1))
        label.set_text(msg.url(nil, id, "label"), ("%.1f"):format(v.dist or 0))
    else
        id = factory.create("#point", pos_xy(v.x, v.y, 1))
    end
    return id
end

local function click(self, position)
    -- if selected == t.move then return end
    print("Click!")

    local x = math.floor(position.x / TILE_SIZE) + MAP_WIDTH/2 + 1
    local y = math.floor(position.z / TILE_SIZE) + MAP_HEIGHT/2 + 1
    x = common.clamp(x, 1, MAP_WIDTH)
    y = common.clamp(y, 1, MAP_HEIGHT)

    local position2 = pos_xy_rnd(x, y, 0, 0)

    if selected == t.house then
        erase(x, y)
        local name = common.get_one_from(props.house)
        if neighbours(y, x, selected) then name = common.get_one_from(props.bighouse) end
        local id = factory.create(name, position2, nil, nil, SCALE)
        objects[y][x] = {id = id, t = t.house}
        total = total + 1
        map.set(x, y, map.solid)
        world[y][x] = 0
        fow.set_b(x, y, 255) -- add to minimap
        go.animate(id, "scale.y", go.PLAYBACK_ONCE_PINGPONG, SCALE.y * 1.2, go.EASING_OUTBACK, .2)
        common.play_sound("button", {speed = 2, gain = .3})

    elseif selected == t.tree then
        erase(x, y)
        local name = common.get_one_from(props.tree2)
        local id = factory.create(name, position2, nil, nil)
        objects[y][x] = {id = id, t = t.tree}
        total = total + 1
        map.set(x, y, map.solid)
        world[y][x] = 0
        fow.set_b(x, y, 255) -- add to minimap
        go.animate(id, "scale.y", go.PLAYBACK_ONCE_PINGPONG, 1.2, go.EASING_OUTBACK, .2)
        common.play_sound("button", {speed = 2, gain = .3})

    elseif selected == t.move then

        local hero = heroes[1]
        if self.path_ids then
            for index, id in ipairs(self.path_ids) do
                go.delete(id)
            end
        end
        self.path_ids = {}
        if hero.path then
            hero.path = nil
            return
        end

        if fow.get(x, y) > 0 then
            local t1 = socket.gettime()
            -- local result, size, cost, path, nears = map.find_path(hero.x, hero.y, x, y)
            local path, cost = astar.a_star(world, {x = hero.x, y = hero.y}, {x = x, y = y})
            print("cost=", cost)
            print("time:", socket.gettime() - t1) -- profiling pathfinder
            if path then
                for index, v in ipairs(path) do
                    local id = point(v)
                    table.insert(self.path_ids, id)
                end

                follow_path(hero, path, self.path_ids,
                  function(obj, done)
                    fow.draw(obj.x, obj.y, obj.visible_radius)
                    if obj.prev_x then fow.set_g(obj.prev_x, obj.prev_y, 0) end
                    fow.set_g(obj.x, obj.y, 255)
                    if #self.path_ids > 0 then
                        local id = table.remove(self.path_ids, 1)
                        go.delete(id)
                    end
                    if not done and obj.path_index % 2 == 0 then
                        common.play_sound("horse", {speed = 1 + math.random() * .2, gain = .7})
                    end
                    if done then obj.path = nil end
                  end)
            else
                noway(x,y)
            end

        else
            print("The tile is covered by the fog of war.", x, y)
            noway(x,y)

            -- local near_result, near_size, nears = map.find_nears(heroes[1].x, heroes[1].y, 12, function(value, x, y)
            --     return value == map.empty and fow.get(x, y) > 0
            -- end)
            local t1 = socket.gettime()
            local nears = astar.find_nearest_cells(world, {x = hero.x, y = hero.y}, hero.visible_radius)
            print("time:", socket.gettime() - t1) -- profiling pathfinder
            if self.path_ids then
                for index, id in ipairs(self.path_ids) do
                    go.delete(id)
                end
            end
            for index, v in ipairs(nears) do
                local id = point(v)
                table.insert(self.path_ids, id)
            end

        end
    end

end

function init(self)
    timer.delay(self.acquire_delay, false, function()
        msg.post(".", "acquire_input_focus")
    end)
    self.touch_down = false
    self.swipe_start_time = 0
    self.camera_initial_x_angle = go.get(self.cam_look_at, "euler.x")

    local function resize()
        local x, y = window.get_size()
        local z = 500 / common.clamp(x/y, .7, 1)
        print(z)
        -- go.animate(self.camera_go_id, "position.z", go.PLAYBACK_ONCE_FORWARD, z, go.EASING_LINEAR, .2)
    end
    broadcast.register("WINDOW_RESIZED", resize)
    resize()
    broadcast.register("select", function(message) 
        selected = message.selected
        print("selected:", selected)
    end)

    broadcast.register("minimap", function(message)
        go.animate(self.cam_look_at, "position", go.PLAYBACK_ONCE_FORWARD, pos_xy(message.x, message.y), go.EASING_LINEAR, .1)
        -- go.set_position(pos_xy(message.x, message.y), self.cam_look_at)
    end)

    common.init_default_random()
    generate(self)


    fow.init(self, MAP_WIDTH, MAP_HEIGHT, TILE_SIZE, self.fow)
    fow.draw(MAP_WIDTH / 2, MAP_HEIGHT / 2, 22)

    for y = 1, MAP_HEIGHT do
        for x = 1, MAP_WIDTH do
            local v = map.get(x, y)
            if v == map.solid then
                fow.set_b(x, y, 255)
            end
        end
    end

end

function final(self)
    broadcast.unregister_all()
    msg.post(".", "release_input_focus")
    fow.final(self)
end

local function screen_to_world(vec, camera_id)
    return common.screen_to_world_plane(vec.x, vec.y, camera_id, up, root)
end


local INERTIA = 0.75
local function pinch_update(self, dt)
    self.cam_euler_dif = (self.cam_euler_dif or 0) * INERTIA

    -- Handle Pinch and Rotate gestures if we have previous and current frames touch positions. 
    if self.p1 and self.p2 and self.f_p1 and self.f_p2 then
        -- local w0 = (self.f_p2 - self.f_p1)
        -- local w1 = (self.p2 - self.p1)
        -- Vectors between fingers in the World coordinate system.
        local w0 = screen_to_world(self.f_p2, self.camera_id) - screen_to_world(self.f_p1, self.camera_id)
        local w1 = screen_to_world(self.p2, self.camera_id) - screen_to_world(self.p1, self.camera_id)

        -- Zoom pinch
        local scale = vmath.length(w0) / math.max(vmath.length(w1), 0.000001)
        local z = go.get_position(self.camera_go_id).z * scale
        go.set(self.camera_go_id, "position.z", common.clamp(z, 300, 940))

        -- Rotate gesture
        local a0 = math.atan2(w0.z, w0.x)
        local a1 = math.atan2(w1.z, w1.x)
        local dif = math.deg(a0 - a1)
        self.cam_euler_dif = dif
    end
    -- Remembers current touches positions for the next frame.
    self.f_p1 = self.p1
    self.f_p2 = self.p2
    self.p1 = nil
    self.p2 = nil

    -- Rotate the camera with an inertia. Ignore the very small difference (in deg) between frames.
    if math.abs(self.cam_euler_dif) > .5 then 
        local angle = (go.get(self.cam_look_at, "euler.y") - self.cam_euler_dif)%360
        go.set(self.cam_look_at, "euler.y", angle)

        -- Blocks microshifting the camera by second axis.
        -- Otherwise euler float rounding errors accumulate (probably) and the camera angle moves away.
        go.set(self.cam_look_at, "euler.x", self.camera_initial_x_angle or -32)
    end

    -- The camera movement
    self.cam_translate = (self.cam_translate or vmath.vector3(0)) * INERTIA

    if self.translate then
        if self.prev_translate then
            local p = screen_to_world(self.translate, self.camera_id) - screen_to_world(self.prev_translate, self.camera_id)
            self.cam_translate = p
        end
    end
    self.prev_translate = self.translate
    self.translate = nil

    -- Set new position to the camera. Ignore small changes.
    -- Clamp borders.
    if vmath.length(self.cam_translate) > 0.01 then
        local position = go.get_position(self.cam_look_at) - self.cam_translate
        position.z = common.clamp(position.z, -MAP_HEIGHT/2*TILE_SIZE, MAP_HEIGHT/2*TILE_SIZE)
        position.x = common.clamp(position.x, -MAP_WIDTH/2*TILE_SIZE, MAP_WIDTH/2*TILE_SIZE)
        go.set_position(position, self.cam_look_at)
    end

end


function update(self, dt)
    light.set_position(go.get_rotation(self.cam_look_at), go.get_position(self.cam_look_at), go.get_world_position(self.camera_go_id))
    common.cam_pos = light.cam_look_at
    pinch_update(self, dt)
    if fow.update(self, dt) then
        -- dirty frame. Need to update textures. 
        local res = go.get("/minimap#sprite", "texture0")
        -- local res = go.get("/ui#ui",  "textures", {key = "fow"})
        -- print(res)
        fow.set_texture(res)
    end

end



local function keyboard_map(self, action_id, action)

    if action_id == triggers.KEY_I and action.released then
        msg.post('@system:', 'toggle_profile')
    elseif action_id == triggers.KEY_O and action.released then 
        msg.post('@system:', 'toggle_physics_debug')
    end

end

local function zoom(self, action_id, action)
     if action_id == hash("mouse_wheel_up") then
        local z = go.get_position(self.camera_go_id).z - self.zoom_speed
        go.set(self.camera_go_id, "position.z", z)
        local ex = go.get(self.cam_look_at, "euler.x") + 1
        go.set(self.cam_look_at, "euler.x", ex)
    elseif action_id == hash("mouse_wheel_down") then
        local z = go.get_position(self.camera_go_id).z + self.zoom_speed
        go.set(self.camera_go_id, "position.z", z)
        local ex = go.get(self.cam_look_at, "euler.x") - 1
        go.set(self.cam_look_at, "euler.x", ex)
    end
end



local left = hash("touch")
local TOUCH_MULTI = hash("touch_multi")
local TOUCH = hash("touch")
local function pinch_on_input(self, action_id, action)
    local ret = true
    -- Multi? (iOS sends it always, Android too?)
    if action_id==TOUCH_MULTI then
        for i, v in ipairs(action.touch) do
            if i == 1 then
                self.p1 = vmath.vector3(v.x, v.y, 0)
            elseif i == 2 then
                self.p2 = vmath.vector3(v.x, v.y, 0)
            end
        end
    -- Single touch (or the first of multi touch + mouse left button)
    elseif action_id==TOUCH and not action.touch then
        self.translate = vmath.vector3(action.x, action.y, 0)
    end

    return ret
end


local CLICK_DELAY = .25
function on_input(self, action_id, action)

    keyboard_map(self, action_id, action)
    zoom(self, action_id, action) -- mouse wheel zoom

    if action_id == left then

        self.touch_down = true
        if action.pressed then
            self.swipe_start_time = socket.gettime()
        end
        if action.released then
            if socket.gettime() - self.swipe_start_time < CLICK_DELAY then
                click(self,  common.screen_to_world_plane(action.x, action.y, self.camera_id, up, root))
            -- broadcast.send("click", {x = action.x, y = action.y, sx = action.screen_x, sy = action.screen_y})
            end
            self.touch_down = false
            self.start_p = nil
        end
    end
    -- 
     -- Multi and single touch handler. Camera movement (mouse + touch) 
    if pinch_on_input(self, action_id, action) then return end

end


function on_message(self, message_id, message, sender)
    if broadcast.on_message(message_id, message, sender) then
        -- message was handled
        return
    end

end