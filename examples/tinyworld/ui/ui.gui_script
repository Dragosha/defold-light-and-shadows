local si        = require 'helper.simple_input'
local monarch   = require "monarch.monarch"
local broadcast = require 'helper.broadcast'
local virtual_stick = require 'helper.virtual_stick'
local common = require 'helper.common'
local light_and_shadows = require "light_and_shadows.light_and_shadows"
local tweener = require 'helper.tweener'

local day = true

local function text_upd()
    gui.set_text(gui.get_node("blur"), day and "On" or "Off")
end

local t = {
    move = 0,
    tree = 1,
    house = 2,
    tower = 3,
}
local selected = 0
local function ui_upd()
    gui.play_flipbook(gui.get_node("move"), selected == t.move and "button_" or "button")
    gui.play_flipbook(gui.get_node("tree"), selected == t.tree and "button_" or "button")
    gui.play_flipbook(gui.get_node("house"), selected == t.house and "button_" or "button")
    -- gui.animate(gui.get_node("corner"), "position.y", day and 400 or -240, gui.EASING_OUTBACK, .2)
end



function init(self)

    -- Simple input. Registre the 'next' button hundler.
    timer.delay(.1, false, function()
        si.acquire()
    end)
    

    si.register("wow", function()
        day = not day
        text_upd()
        broadcast.send("day", {value = day})
        ui_upd()
    end)
    si.register("move", function()
        selected = t.move
        broadcast.send("select", {selected = selected})
        ui_upd()
    end)
    si.register("tree", function()
        selected = t.tree
        broadcast.send("select", {selected = selected})
        ui_upd()
    end)
    si.register("house", function()
        selected = t.house
        broadcast.send("select", {selected = selected})
        ui_upd()
    end)

    si.register("settings", function()
        light_and_shadows.blur = not light_and_shadows.blur
        light_and_shadows.blur_power = 1
        tweener.tween(tweener.linear, 1, 4, .3, function(value, is_final_call)
            light_and_shadows.blur_power = value
        end)
        text_upd()
        ui_upd()
    end)

    text_upd()
    ui_upd()

    -- The UI scaling depends on the window resolution.
    local function resize()
        local x, y, zoom = virtual_stick.get_aspect_ratio()
        local scale = vmath.vector3(zoom, zoom, 1)
        -- print("next", scale)
        gui.set_scale(gui.get_node("corner"), scale)
        gui.set_scale(gui.get_node("corner2"), scale)
    end

    broadcast.register("WINDOW_RESIZED", resize)
    resize()

end

function final(self)
    -- light_and_shadows.blur = false
    broadcast.unregister_all()
    si.unregister()
    si.release()
end

function update(self, dt)
end

function on_message(self, message_id, message, sender)
    if broadcast.on_message(message_id, message, sender) then
        -- message was handled
        return
    end
end

function on_input(self, action_id, action)
    if si.on_input(self, action_id, action) then
        -- input message was handled
        return true
    end
end


