local rendercam = require 'rendercam.rendercam'
local triggers = require "in.triggers"
local monarch = require 'monarch.monarch'
local light = require 'light_and_shadows.light'
local common = require 'helper.common'

go.property("cam", msg.url("cam"))

function init(self)
    msg.post(".", "acquire_input_focus")
    self.touch_down = false
    self.swipe_start_time = 0
end

function final(self)
    msg.post(".", "release_input_focus")
end

function update(self, dt)
    local view = go.get_rotation(self.cam)
    light.cam_view = view
    local pos = go.get_position("cam")
    light.cam_pos = pos
    common.cam_pos = pos
end

function on_message(self, message_id, message, sender)
    if message_id then
    end
end

local function keyboard_map(self, action_id, action)

    if (	action_id == triggers.KEY_ESC or
             action_id == triggers.KEY_P or
             action_id == triggers.GAMEPAD_START or
            action_id == triggers.GAMEPAD_BACK) 
            and action.released then

    elseif action_id == triggers.KEY_I and action.released then
        msg.post('@system:', 'toggle_profile')

    elseif action_id == triggers.KEY_O and action.released then 
        msg.post('@system:', 'toggle_physics_debug')

    end

end

local function zoom(self, action_id, action)
     if action_id == hash("mouse_wheel_up") then
        rendercam.zoom(10)
    elseif action_id == hash("mouse_wheel_down") then
        rendercam.zoom(-10)
    end
end

local left = hash("mouse_button_left")
local function click(self, action)

    local from, to = rendercam.screen_to_world_ray(action.screen_x, action.screen_y, false)
    local result = physics.raycast(from, to, {hash("triggers"),hash("movable"), hash("item")}, {all = false})
    if result ~= nil then
        local r = result[1]
        if r then
            print("click:", r.id )
            common.play_sound("button", common.pan(r.position))
            -- go.animate(r.id, "scale", go.PLAYBACK_ONCE_PINGPONG, go.get_scale(r.id)*1.1, go.EASING_INBOUNCE, .1, 0, function() go.delete(r.id) end)
            go.animate(r.id, "scale", go.PLAYBACK_ONCE_PINGPONG, go.get_scale(r.id)*1.1, go.EASING_INBOUNCE, .2, 0, function()  end)
        end
        
        
    else
        local p = rendercam.screen_to_world_plane(action.screen_x, action.screen_y, vmath.vector3(0, 1, 0), go.get_position("root"))
    end
    
    -- print("click:", to )
end
function on_input(self, action_id, action)

    keyboard_map(self, action_id, action)
    zoom(self, action_id, action)
       
    if action_id == left then
        self.touch_down = true
        if action.pressed then
            self.swipe_start_time = socket.gettime()
        end
        if action.released then
            if socket.gettime() - self.swipe_start_time < .5 then
                click(self, action)
            end
            self.touch_down = false
        end
    end
    
    if self.touch_down and action_id == nil then
        local view =  go.get_rotation(self.cam)
        local dx, dy = rendercam.screen_to_viewport(action.dx, action.dy, true)
        local v3 = vmath.vector3(dx, 0, -dy)
        local position = go.get_position(self.cam)
        local v2 = position - vmath.rotate(view, v3)*0.1
        v2.y = position.y
        go.cancel_animations(self.cam, "position")
        go.set_position(v2, self.cam)
        -- print("cam pos:", math.floor(v2.x),",", math.floor(v2.y),",",math.floor(v2.z))
    end
    
end

